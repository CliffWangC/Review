<h1 id="1">Database</h1>

* [目录](#1)
	 * [基础](#2)
		* [基础属性比较](#2.1)
		* [基础增删改查](#2.2)
		* [FOREIGN KEY](#2.3)
		* [聚集函数](#2.4)
		* [分组](#2.5)
		* [派生关系](#2.6)		
	 * [进阶](#3)
		* [B+ Tree 索引](#3.1)
		* [MyISAM 与 InnoDb 的差别](#3.2)
		* [视图 view](#3.3)
		* [存储过程 store procedure](#3.4)
		* [触发器 trigger](#3.5)
		* [分表](#3.6)	
		* [事务 锁](#3.7)	

	 

<h1 id="2">基础</h1>

<h2 id="2.1">基础属性比较</h2>

<ul>
	<li>
		<h3 id="2.1.1">Timestamp & datetime</h3>
		timestamp 只能到2037年  占用4bytes 搜寻比datetime快 受到时区影响 <br>
		datetime 占用8bytes 但可以到9999年
	</li>
	<li>
		<h3 id="2.1.2">vachar & char</h3>
		char和varchar是一样的字符型，不同在于varchar比char更灵活，精确，且不占内存空间。
		另外varchar只取字符，而char将补齐字段。虽然varchar比char更精确，但varchar的速度却比char慢。
		一般的对于长度小于4的字符串，我们采用char，对于大于20的使用varchar，4-20之间的根据自己的情况定。对于大多数情形，使用varchar会更好。
	</li>
</ul>




<h2 id="2.2">基础增删改查</h2>
<ul>
	<li>insert</li>
	<li>update</li>
	<li>delete</li>
	<li>select</li>
</ul>

<h2 id="2.3">FOREIGN KEY</h2>
<ul>
	<li>
		作为主码的关系称为基本关系，作为`外码`的关系称为`依赖`关系
	</li>
	<li>
		删除基本关系元组
		<ul>
			<li>
				RESTRICT方式
				只有当依赖关系中没有一个外码值与要删除的基本关系的主码值相对应时，才可以删除该元组，否则系统拒绝此删除操作
			</li>
			<li>
				CASCADE方式
				将依赖关系中所有外码值与基本关系中要删除的主码值所对应的元组一起删除
			</li>
			<li>
				SET NULL方式
				删除基本关系中元组时，将依赖关系中与基本关系中被删主码值相对应的外码值置为空值
			</li>
		</ul>
	</li>
</ul>

<h2 id="2.4">聚集函数</h2>
<ul>
	<li>平均值：avg</li>
	<li>最小值：min</li>
	<li>最大值：max</li>
	<li>总和：sum</li>
	<li>记数：count</li>	
</ul>

<h2 id="2.5">分组</h2>
group by   列名  [having   条件表达式]
group by将表中的元组按指定列上值相等的原则分组，然后可在每一分组上使用聚集函数，得到单一值
having则对分组进行选择，只将聚集函数作用到满足条件的分组上

<h2 id="2.6">派生关系</h2>
一个query中只能使用一个聚集函数 故很多时候需要使用派生关系
select       SNAME , AVG_GRADE
from
	  (select	SNAME , avg（GRADE）
		from  	S,SC
		where 	SC.S# = S.S#
		group by	SC .S#)
       as    result(SNAME , AVG_GRADE )
	  where   	AVG_GRADE  >=  60


<h1 id="3">进阶</h1>

<h2 id="3.1">B+ Tree 索引</h2>
通过事先排好序，从而在查找时可以应用二分查找等高效率的算法。<br>
一般的顺序查找，复杂度为O(n)，而二分查找复杂度为O(log2n)。当n很大时，二者的效率相差及其悬殊。<br>
 不管数据表有无索引，首先在SGA的数据缓冲区中查找所需要的数据，如果数据缓冲区中没有需要的数据时，服务器进程才去读磁盘。<br>
1、无索引，直接去读表数据存放的磁盘块，读到数据缓冲区中再查找需要的数据。<br>
2、有索引，先读入索引表，通过索引表直接找到所需数据的物理地址，并把数据读入数据缓冲区中。<br>

索引有什么副作用吗？

（1）索引是有大量数据的时候才建立的，没有大量数据反而会浪费时间，因为索引是使用二叉树建立.<br>
（2）当一个系统查询比较频繁，而新建，修改等操作比较少时，可以创建索引，这样查询的速度会比以前快很多，同时也带来弊端，就是新建或修改等操作时，比没有索引或没有建立覆盖索引时的要慢。<br>
（3）索引并不是越多越好，太多索引会占用很多的索引表空间，甚至比存储一条记录更多。<br>
对于需要频繁新增记录的表，最好不要创建索引，没有索引的表，执行insert、append都很快，有了索引以后，会多一个维护索引的操作，一些大表可能导致insert 速度非常慢。

Hash 索引<br>
（1）哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快。<br>
（2）如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据<br>
（3）如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索<br>
（4）同理，哈希索引也没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询<br>
（5）哈希索引也不支持多列联合索引的最左匹配规则；<br>
（6）B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。

<h2 id="3.2">MyISAM 与 InnoDb 的差别</h2>

myisam读的效果好，写的效率差，这和它数据存储格式，索引的指针和锁的策略有关的，它的数据是顺序存储的（innodb数据存储方式是聚簇索引），<br>
他的索引btree上的节点是一个指向数据物理位置的指针，所以查找起来很快，（innodb索引节点存的则是数据的主键，所以需要根据主键二次查找）；<br>
myisam锁是表锁，只有读读之间是并发的，写写之间和读写之间（读和插入之间是可以并发的，去设置concurrent_insert参数，<br>
定期执行表优化操作，更新操作就没有办法了）是串行的，所以写起来慢，并且默认的写优先级比读优先级高，<br>
高到写操作来了后，可以马上插入到读操作前面去，如果批量写，会导致读请求饿死，所以要设置读写优先级或设置多少写操作后执行读操作的策略;<br>
myisam不要使用查询时间太长的sql，如果策略使用不当，也会导致写饿死，所以尽量去拆分查询效率低的sql,innodb一般都是行锁，<br>
这个一般指的是sql用到索引的时候，行锁是加在索引上的，不是加在数据记录上的，如果sql没有用到索引，<br>
仍然会锁定表,mysql的读写之间是可以并发的，普通的select是不需要锁的，当查询的记录遇到锁时，用的是一致性的非锁定快照读，<br>
也就是根据数据库隔离级别策略，会去读被锁定行的快照，其它更新或加锁读语句用的是当前读，读取原始行；因为普通读与写不冲突，<br>
所以innodb不会出现读写饿死的情况，又因为在使用索引的时候用的是行锁，锁的粒度小，竞争相同锁的情况就少，就增加了并发处理，<br>
所以并发读写的效率还是很优秀的，问题在于索引查询后的根据主键的二次查找导致效率低；<br>
http://blog.csdn.net/z702143700/article/details/46049101<br>
并且InnoDB支援事务时的行级锁

<h2 id="3.3">视图 view</h2>
视图是虚拟的表，它只包含使用时动态检索数据的查询。

使用视图的好处
<ul>
	<li>重用SQL语句</li>
	<li>简化复杂的SQL操作（可以方便的重用它而不必知道它的基本查询细节）</li>
	<li>使用表的组成部分而不是整个表</li>
	<li>保护数据（可以给用户授予表的部分访问权限而不是整个表的访问权限）</li>
	<li>更改数据格式和表示（视图可返回与底层表的表示和格式不同的数据）</li>	
</ul>

视图的规则和限制
<ul>
	<li>视图必须唯一命名（视图与别的视图或表不能有相同的名字）</li>
	<li>创建的视图数目没有限制</li>
	<li>为了创建视图，必须有足够的访问权限</li>
	<li>视图可以嵌套</li>
	<li>order by也可用于视图；但如果该视图中检索数据的select语句包含order by，那么该视图中的order by将被覆盖</li>	
	<li>视图不能索引，也不能有关联的触发器或默认值</li>	
	<li>视图可以好表一起使用</li>	
</ul>

**视图并不会令查询变得更快

<h2 id="3.4">存储过程 store procedure</h2>

优点
<ul>
	<li>在生产环境下，可以通过直接修改存储过程的方式修改业务逻辑（或bug），而不用重启服务器。但这一点便利被许多人滥用了。有人直接就在正式服务器上修改存储过程，而没有经过完整的测试，后果非常严重。</li>
	<li>执行速度快。存储过程经过编译之后会比单独一条一条执行要快。但这个效率真是没太大影响。如果是要做大数据量的导入、同步，我们可以用其它手段。</li>
	<li>减少网络传输。存储过程直接就在数据库服务器上跑，所有的数据访问都在服务器内部进行，不需要传输数据到其它终端。但我们的应付服务器通常与数据库是在同一内网，大数据的访问的瓶颈会是硬盘的速度，而不是网速。</li>
	<li>能够解决presentation与数据之间的差异，说得文艺青年点就是解决OO模型与二维数据持久化之间的阻抗。领域模型和数据模型的设计可能不是同一个人（一个是SA，另一个是DBA），两者的分歧可能会很大——这不奇怪，一个是以OO的思想来设计，一个是结构化的数据来设计，大家互不妥协——你说为了软件的弹性必须这么设计，他说为了效率必须那样设计，为了抹平鸿沟，就用存储过程来做数据存储的逻辑映射（把属性映射到字段）。</li>
	<li>方便DBA优化。所有的SQL集中在一个地方，DBA会很高兴。这一点算是ORM的软肋。不过按照CQRS框架的思想，查询是用存储过程还是ORM，还真不是问题——DBA对数据库的优化，ORM一样会受益。况且放在ORM中还能用二级缓存，有些时候效率还会更高。</li>
</ul>

缺点
<ul>
	<li>SQL本身是一种结构化查询语言，加上了一些控制（赋值、循环和异常处理等），但不是OO的，本质上还是过程化的，面对复杂的业务逻辑，过程化的处理会很吃力。这一点算致命伤。</li>
	<li>不便于调试。基本上没有较好的调试器，很多时候是用print来调试，但用这种方法调试长达数百行的存储过程简直是噩梦。好吧，这一点不算啥，C#/java一样能写出噩梦般的代码。</li>
	<li>没办法应用缓存。虽然有全局临时表之类的方法可以做缓存，但同样加重了数据库的负担。如果缓存并发严重，经常要加锁，那效率实在堪忧。</li>
	<li>无法适应数据库的切割（水平或垂直切割）。数据库切割之后，存储过程并不清楚数据存储在哪个数据库中。</li>
	<li>精通SQL的新手越来越少</li>
</ul>

<h2 id="3.5">触发器 trigger</h2>
SQL触发器是存储在数据库目录中的一组SQL语句。每当与表相关联的事件发生时，即会执行或触发SQL触发器，例如插入，更新或删除。

SQL触发器是一种特殊类型的存储过程。 这是特别的，因为它不像直接像存储过程那样调用。 触发器和存储过程之间的主要区别在于，当对表执行数据修改事件时，会自动调用触发器，而存储过程必须要明确地调用。
优点
<ul>
	<li>SQL触发器提供了检查数据完整性的替代方法。</li>
	<li>SQL触发器可以捕获数据库层中业务逻辑中的错误。</li>
	<li>SQL触发器提供了运行计划任务的另一种方法。通过使用SQL触发器，您不必等待运行计划的任务，因为在对表中的数据进行更改之前或之后自动调用触发器。</li>
	<li>SQL触发器对于审核表中数据的更改非常有用。</li>
</ul>

缺点
<ul>
	<li>SQL触发器只能提供扩展验证，并且无法替换所有验证。一些简单的验证必须在应用层完成。 例如，您可以使用JavaScript或服务器端使用服务器端脚本语言(如JSP，PHP，ASP.NET，Perl等)来验证客户端的用户输入。</li>
	<li>从客户端应用程序调用和执行SQL触发器不可见，因此很难弄清数据库层中发生的情况。</li>
	<li>SQL触发器可能会增加数据库服务器的开销。</li>
</ul>

<h2 id="3.6">分表</h2>

表分割有两种方式：　
<ul>
	<li>
		水平分割：根据一列或多列数据的值把数据行放到两个独立的表中。
	　　水平分割通常在下面的情况下使用。
	　　•表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询速度。
	　　•表中的数据本来就有独立性，例如表中分别记录各个地区的数据或不同时期的数据，特别是有些数据常用，而另外一些数据不常用。
	　　•需要把数据存放到多个介质上。
		水平分割会给应用增加复杂度，它通常在查询时需要多个表名，查询所有数据需要union操作。在许多数据库应用中，这种复杂性会超过它带来的优点，因为只 要索引关键字不大，则在索引用于查询时，表中增加两到三倍数据量，查询时也就增加读一个索引层的磁盘次数。
	</li>
	<li>
		垂直分割：把主码和一些列放到一个表，然后把主码和另外的列放到另一个表中。
	　　如果一个表中某些列常用，而另外一些列不常用，则可以采用垂直分割，另外垂直分割可以使得数据行变小，一个数据页就能存放更多的数据，在查询时就会减少I/O次数。其缺点是需要管理冗余列，查询所有数据需要join操作。
	</li>
</ul>

<h2 id="3.7">事务 锁</h2>
MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！<br>
在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。<br>
事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。<br>
事务用来管理 insert,update,delete 语句<br>
一般来说，事务是必须满足4个条件（ACID）： Atomicity（原子性）、Consistency（稳定性）、Isolation（隔离性）、Durability（可靠性）
<ol>
	<li>事务的原子性：一组事务，要么成功；要么撤回。</li>
	<li>稳定性 ：有非法数据（外键约束之类），事务撤回。</li>
	<li>隔离性：事务独立运行。一个事务处理后的结果，影响了其他事务，那么其他事务会撤回。事务的100%隔离，需要牺牲速度。</li>
	<li>可靠性：软、硬件崩溃后，InnoDB数据表驱动会利用日志文件重构修改。可靠性和高速度不可兼得， innodb_flush_log_at_trx_commit 选项 决定什么时候把事务保存到日志里。</li>
</ol>

锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。<br>
如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。<br>
从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。本章我们着重讨论MySQL锁机制的特点，常见的锁问题，以及解决MySQL锁问题的一些方法或建议。<br>

MySQL锁概述
相对其他数据库而言，MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。<br>
比如，MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking）；BDB存储引擎采用的是页面锁（page-level locking），但也支持表级锁；InnoDB存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。<br>
MySQL这3种锁的特性可大致归纳如下。<br>
开销、加锁速度、死锁、粒度、并发性能<br>
<ul>
	<li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</li>
	<li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</li>
	<li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li>
</ul>
